<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>BitShade-Pro — Private BTC → Starknet</title>
<meta name="description" content="BitShade-Pro: Private BTC → Starknet bridge UI — notes, Merkle proofs, nullifiers, encrypted backups. Beginner & Advanced modes."/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#06121a; --panel:#071726; --muted:#9fb0c6; --accent:#7c5cff;
    --accent-2:#4f46e5; --glass:rgba(255,255,255,0.02); --card-shadow: 0 8px 28px rgba(2,6,23,0.6);
    --ok:#16a34a; --bad:#ef4444; --glass-2: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:0;background:linear-gradient(180deg,#02121a,#04131b);color:#e6eef8;padding:18px;line-height:1.35}
  .wrap{max-width:1200px;margin:0 auto}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:16px}
  h1{margin:0;font-size:20px}
  .lead{margin:0;color:var(--muted);font-size:13px}
  .top-stats{display:flex;gap:10px;align-items:center}
  .stat{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:10px;border-radius:10px;min-width:110px;text-align:center}
  .stat .small{font-size:12px;color:var(--muted)}
  .stat .big{font-weight:700;font-family:ui-monospace, SFMono-Regular, Menlo, monospace;font-size:16px}
  .grid{display:grid;grid-template-columns:1fr 420px;gap:18px}
  .card{background:var(--panel);border-radius:12px;padding:14px;box-shadow:var(--card-shadow)}
  .row{display:flex;gap:8px;align-items:center}
  button{background:linear-gradient(90deg,var(--accent-2),var(--accent));border:0;color:#fff;padding:9px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px 10px}
  input,textarea,select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  .small{font-size:13px;color:var(--muted)}
  .tiny{font-size:12px;color:var(--muted)}
  .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:12px}
  .log{height:180px;overflow:auto;background:var(--glass);padding:10px;border-radius:8px;font-size:13px}
  .muted{color:var(--muted)}
  .success{color:var(--ok)}
  .danger{color:var(--bad)}
  .list{max-height:260px;overflow:auto}
  .controls{display:flex;gap:8px;align-items:center}
  footer{margin-top:18px;color:var(--muted);font-size:12px;text-align:center}
  .badge{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,0.3)}
  .help{font-size:13px;color:var(--muted);padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02))}
  .center{display:flex;align-items:center;justify-content:center}
  .muted-2{color:#8aa6bf}
  .toggle{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px 8px;border-radius:8px;color:var(--muted);cursor:pointer}
  .row-wrap{display:flex;flex-wrap:wrap;gap:8px}
  /* merkle viz */
  .merkle-canvas{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));padding:12px;border-radius:10px}
  .node{display:inline-flex;align-items:center;justify-content:center;width:78px;height:28px;border-radius:6px;background:rgba(255,255,255,0.02);margin:6px;font-size:11px}
  .node.leaf{background:linear-gradient(90deg,#0b2a3a,#08364a)}
  .node.root{background:linear-gradient(90deg,#243bff,#7c5cff);font-weight:700}
  .node.active{box-shadow:0 6px 20px rgba(124,92,255,0.15);outline:2px solid rgba(124,92,255,0.12)}
  .tree-row{display:flex;gap:12px;align-items:center;justify-content:flex-start;flex-wrap:nowrap;overflow:auto;padding:6px}
  .hint{font-size:12px;color:var(--muted);padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.01)}
  .tx-card{padding:10px;border-radius:10px;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02))}
  .help-step{padding:12px;border-radius:10px;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));margin-bottom:8px}
  .studio{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} .studio{grid-template-columns:1fr} header{flex-direction:column;align-items:flex-start} .merkle-canvas{overflow:auto} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>BitShade-Pro</h1>
      <p class="lead">Private BTC → Starknet UX — notes, Merkle proofs, nullifiers, encrypted backup. Beginner & Advanced views.</p>
      <div class="tiny muted-2" style="margin-top:6px">Show judges: deposit → inspect proof → withdraw → show nullifier & exported proof JSON.</div>
    </div>

    <div class="top-stats">
      <div class="stat">
        <div class="small">Mock BTC</div>
        <div class="big mono" id="btcBal">0.500000</div>
      </div>
      <div class="stat">
        <div class="small">wSTRK</div>
        <div class="big mono" id="wBal">0.0000</div>
      </div>
      <div style="width:6px"></div>
      <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
        <div style="display:flex;gap:6px">
          <button id="modeBegin" class="toggle">Beginner</button>
          <button id="modeAdv" class="toggle">Advanced</button>
        </div>
        <div class="tiny muted" id="modeHelp">Mode: Beginner</div>
      </div>
    </div>
  </header>

  <div class="grid">
    <!-- main column -->
    <div>
      <!-- Guided / Tutorial -->
      <div id="tutorial" class="card" style="margin-bottom:14px">
        <div class="row" style="justify-content:space-between">
          <div>
            <h3 style="margin:0 0 6px">Quick Guided Tour</h3>
            <div class="small muted">Follow these steps to experience private BTC → wSTRK transfers. Switch to Advanced for technical inspection.</div>
          </div>
          <div class="center">
            <button class="ghost" id="btnResetTutorial">Reset Tour</button>
          </div>
        </div>
        <div style="height:10px"></div>
        <div id="tourContent">
          <!-- filled by JS -->
        </div>
      </div>

      <!-- Deposit -->
      <div class="card" style="margin-bottom:12px">
        <div class="row" style="justify-content:space-between">
          <div>
            <h3 style="margin:0 0 6px">Deposit (Mock BTC → wSTRK)</h3>
            <div class="small muted">Create private notes representing wrapped balance. Each note acts like a UTXO.</div>
          </div>
          <div class="tiny muted">Bridge selector</div>
        </div>

        <div style="height:10px"></div>
        <div class="row" style="gap:8px">
          <input id="depositAmount" placeholder="amount BTC (e.g. 0.01)" style="max-width:200px"/>
          <select id="depositPreset" style="max-width:140px">
            <option value="">preset</option>
            <option value="0.01">0.01 BTC</option>
            <option value="0.05">0.05 BTC</option>
            <option value="0.1">0.1 BTC</option>
          </select>
          <button id="btnDeposit">Deposit</button>
          <button class="ghost" id="btnBatchDeposit">Batch (3×0.01)</button>
        </div>

        <div style="height:8px"></div>
        <div class="help">Tip: Notes are generated locally and encrypted exports let you restore them on another device.</div>
      </div>

      <!-- Withdraw -->
      <div class="card" style="margin-bottom:12px">
        <h3 style="margin:0 0 8px">Withdraw — choose coverage method</h3>
        <div class="small muted">Paste a note to spend it exactly, or select multiple notes to cover any amount. App creates change notes automatically.</div>
        <div style="height:10px"></div>

        <div class="row" style="gap:10px;align-items:flex-start">
          <div style="flex:1">
            <textarea id="noteInput" rows="2" placeholder="paste a single note here (optional)"></textarea>
            <div style="height:8px"></div>
            <input id="withdrawAmount" placeholder="withdraw amount (wSTRK)"/>
            <div style="height:8px"></div>
            <input id="destAddr" placeholder="destination address (mock) e.g. 0x12...9fab"/>
            <div style="height:8px"></div>
            <label class="tiny"><input type="checkbox" id="checkboxGasless"/> Gasless (Paymaster simulated)</label>
            <div style="height:10px"></div>
            <div class="row-wrap">
              <button id="btnAutoSelect">Auto-select notes</button>
              <button id="btnWithdraw">Withdraw</button>
              <button class="ghost" id="btnVerifyProof">Verify proof</button>
              <button class="ghost" id="btnShowTx">Show sample tx</button>
            </div>

            <div style="height:8px"></div>
            <div id="withdrawNote" class="tiny muted"></div>
          </div>

          <div style="width:240px">
            <div class="pill tiny">Selection</div>
            <div style="height:8px"></div>
            <div id="notesForSelect" class="list mono small" style="max-height:220px;overflow:auto"></div>
          </div>
        </div>
      </div>

      <!-- Activity -->
      <div class="card" style="margin-bottom:12px">
        <h3 style="margin:0 0 8px">Activity & Receipts</h3>
        <div class="tiny muted">Chronological activity — click a tx to expand. Copy or download proofs for audit.</div>
        <div style="height:8px"></div>
        <div id="txLog" class="log mono"></div>
      </div>

      <!-- Tools -->
      <div class="card" style="margin-bottom:14px">
        <h3 style="margin:0 0 8px">Quick Tools</h3>
        <div class="row" style="gap:8px;margin-bottom:8px">
          <button class="ghost" id="btnDemoRun">One-click Demo Run</button>
          <button class="ghost" id="btnExportEnc">Export Encrypted Backup</button>
          <button class="ghost" id="btnImportEnc">Import Encrypted Backup</button>
          <button class="ghost" id="btnReset">Reset Demo</button>
        </div>
        <div class="tiny muted">Backups use AES-GCM with PBKDF2 (200k iterations). Use a strong password.</div>
      </div>
    </div>

    <!-- right column: inspectors, merkle viz, notes -->
    <div>
      <div class="card" style="margin-bottom:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <h3 style="margin:0 0 6px">Pool Inspector</h3>
          <div class="tiny muted">Merkle leaves (SHA-256)</div>
        </div>
        <div style="height:8px"></div>
        <div class="merkle-canvas">
          <div class="pill tiny">Root</div>
          <div id="root" class="mono" style="margin-top:8px;font-size:12px">—</div>
          <div class="tiny muted" id="poolCount" style="margin-top:6px">pool size: 0</div>
          <div style="height:10px"></div>
          <div id="merkleViz" style="min-height:110px"></div>
          <div style="height:10px"></div>
          <div class="row" style="gap:8px">
            <button id="btnSyncRootOnChain">Sync root → Starknet (sim)</button>
            <button id="btnCheckOnChain" class="ghost">Check on-chain root</button>
          </div>
          <div id="onchainStatus" class="tiny muted" style="margin-top:8px"></div>
        </div>
      </div>

      <div class="card" style="margin-bottom:12px">
        <h3 style="margin:0 0 6px">My Notes</h3>
        <div class="small muted">Each note = secret + leaf + amount. Keep secrets safe. Reveal with confirmation.</div>
        <div style="height:8px"></div>
        <div id="myNotes" class="list"></div>
      </div>

      <div class="card" style="margin-bottom:12px">
        <h3 style="margin:0 0 6px">Nullifiers (spent)</h3>
        <div class="small muted">Used nullifiers prevent double-spend. They are not reversible.</div>
        <div id="nulls" class="mono tiny" style="margin-top:8px;max-height:120px;overflow:auto"></div>
      </div>

      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <h3 style="margin:0 0 6px">Glock — Alpen (Roadmap)</h3>
          <div class="badge tiny" id="glockBadge">Glock (Planned)</div>
        </div>
        <div class="small muted">Glock is a trust-minimized verifier for BTC→Starknet. UI & proof flow are Glock-ready.</div>
        <div style="height:10px"></div>
        <div class="row" style="justify-content:flex-end">
          <button class="ghost" id="btnGlockInfo">What is Glock?</button>
        </div>
      </div>
    </div>
  </div>

  <footer>BitShade-Pro — Non-custodial privacy bridge UX. For production: on-chain verifiers (Garaga/Noir), Glock integration, and audits required.</footer>
</div>

<!-- Modals -->
<div id="confirmModal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.7);align-items:center;justify-content:center;padding:18px">
  <div style="max-width:520px;margin:auto;background:var(--panel);border-radius:10px;padding:14px">
    <div id="confirmText" class="small muted"></div>
    <div style="height:12px"></div>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="confirmCancel" class="ghost">Cancel</button>
      <button id="confirmOk">Confirm</button>
    </div>
  </div>
</div>

<div id="noteRevealModal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.7);align-items:center;justify-content:center;padding:18px">
  <div style="max-width:760px;margin:auto;background:var(--panel);border-radius:10px;padding:14px">
    <h3 style="margin:0 0 8px">Reveal Note (confirm)</h3>
    <div class="small muted">You are about to reveal a secret note. Keep this private — anyone with this note can spend the funds.</div>
    <pre id="revealText" style="background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-top:10px;overflow:auto"></pre>
    <div style="height:12px"></div>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="revealCancel" class="ghost">Close</button>
      <button id="revealCopy">Copy to clipboard</button>
    </div>
  </div>
</div>

<!-- Glock Modal (reuse) -->
<div id="glockModal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.7);align-items:center;justify-content:center;padding:24px;">
  <div style="max-width:760px;margin:auto;background:var(--panel);border-radius:10px;padding:18px;color:#e6eef8">
    <h3 style="margin:0 0 8px">Glock (Alpen) — Trust-minimized BTC verification</h3>
    <p style="color:var(--muted);margin:0 0 12px">
      Glock enables provable BTC transfers to be validated on Starknet without trusted wrappers. BitShade-Pro is designed to plug into Glock outputs for future production deployments.
    </p>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="btnGlockClose">Close</button>
      <a href="https://www.starknet.io/blog/starknet-alpen-bitcoin-glock/" target="_blank" rel="noreferrer"><button class="ghost">Read announcement</button></a>
    </div>
  </div>
</div>

<script>
/* Improved BitShade-Pro: interactive UI + merkle viz + tutorial
   Single-file app: HTML + CSS + JS only.
*/

// Utilities
const $ = id => document.getElementById(id);
const nowISO = () => (new Date()).toISOString();
const toFixed = (n, d=6) => Number(n).toFixed(d);
function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;'); }
function buf2hex(buffer){ const bytes=new Uint8Array(buffer); return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join(''); }
async function sha256Hex(text){ const enc=new TextEncoder(); const data=enc.encode(text); const h=await crypto.subtle.digest('SHA-256', data); return buf2hex(h); }
function randB64(len=32){ const a=crypto.getRandomValues(new Uint8Array(len)); let s=''; for(let i=0;i<a.length;i++) s+=String.fromCharCode(a[i]); return btoa(s); }
function copyToClipboard(text){ navigator.clipboard?.writeText(text).then(()=>uiLog('Copied to clipboard')) .catch(()=>{}); }

// Fake tx generator (credible-looking)
function fakeTxHash(){ const r = crypto.getRandomValues(new Uint8Array(16)); return '0x' + Array.from(r).map(b=>b.toString(16).padStart(2,'0')).join(''); }

// State
const KEY = 'bitshade_pro_state_v3';
let state = { btcBalance:0.5, wBalance:0.0, notes:[], leaves:[], nulls:[], txs:[] };
function save(){ localStorage.setItem(KEY, JSON.stringify(state)); }
function load(){ try{ const s=JSON.parse(localStorage.getItem(KEY)); if(s) state=s; }catch(e){} }
load(); renderAll();

// UI helpers
function uiLog(msg, lvl='info'){
  const el = document.createElement('div');
  el.innerHTML = `<div style="display:flex;justify-content:space-between"><div><strong class="mono small">${(new Date()).toLocaleTimeString()}</strong> — ${escapeHtml(msg)}</div></div>`;
  if(lvl==='error') el.style.color = 'var(--bad)';
  $('txLog').prepend(el);
}
function pushTx(type, summary, meta={}){ const tx={type,time:nowISO(),summary,meta}; state.txs.push(tx); save(); renderTxs(); uiLog(`${type}: ${summary}`); return tx; }

// Renderers
function renderAll(){ $('btcBal').textContent = toFixed(state.btcBalance,6); $('wBal').textContent = toFixed(state.wBalance,4); renderLeaves(); renderNotes(); renderNulls(); renderRoot(); renderTxs(); renderTour(); renderModeHelp(); }
function renderLeaves(){
  const box = $('merkleViz'); box.innerHTML = '';
  if(!state.leaves.length){ box.innerHTML = '<div class="tiny muted">no leaves</div>'; return; }
  // create a simple tree layout levels
  const levels = buildTreeLevels(state.leaves);
  // Render each level as a row
  levels.forEach((lvl,li)=>{
    const row = document.createElement('div'); row.className='tree-row';
    lvl.forEach((node,i)=>{
      const div = document.createElement('div'); div.className='node ' + (li===levels.length-1?'root': (li===0?'leaf':'')); div.textContent = node.slice(0,6)+'...';
      div.dataset.level = li; div.dataset.index = i;
      div.onclick = ()=>{ // show path to root
        highlightPath(li,i,levels);
      };
      row.appendChild(div);
    });
    box.appendChild(row);
  });
}
function renderNotes(){
  const box = $('myNotes'); box.innerHTML = '';
  if(!state.notes.length){ box.innerHTML = '<div class="muted tiny">no notes stored</div>'; return; }
  state.notes.forEach((n,idx)=>{
    const [s,leaf,amt] = n.split(':');
    const el = document.createElement('div'); el.style.padding='8px 0'; el.style.borderBottom='1px dashed rgba(255,255,255,0.02)';
    el.innerHTML = `<div class="mono">${leaf.substr(0,18)}... - <span class="tiny muted">${amt} wSTRK</span></div>
      <div style="margin-top:6px" class="tiny">
        <button class="ghost" data-copy="${idx}">Copy</button>
        <button class="ghost" data-reveal="${idx}">Reveal</button>
        <button class="ghost" data-dl="${idx}">Download</button>
      </div>`;
    box.appendChild(el);
  });
  box.querySelectorAll('[data-copy]').forEach(b=>b.onclick=()=>{ const i=b.getAttribute('data-copy'); copyToClipboard(state.notes[i]); uiLog('Note copied'); });
  box.querySelectorAll('[data-dl]').forEach(b=>b.onclick=()=>{ const i=b.getAttribute('data-dl'); downloadText(`note-${i}.txt`, state.notes[i]); uiLog('Note downloaded'); });
  box.querySelectorAll('[data-reveal]').forEach(b=>b.onclick=()=>{ const i=b.getAttribute('data-reveal'); showRevealModal(state.notes[i]); });
}
function renderNulls(){ const n = $('nulls'); n.innerHTML = state.nulls.length? state.nulls.map(x=>`<div>${x.substr(0,14)}...</div>`).join('') : '<div class="muted tiny">none</div>'; }
async function renderRoot(){ const root=await calcMerkleRoot(state.leaves); $('root').textContent = root || '—'; $('poolCount').textContent = 'pool size: '+state.leaves.length; }
function renderTxs(){
  const box = $('txLog'); box.innerHTML = '';
  if(!state.txs.length){ box.innerHTML = '<div class="muted tiny">no activity yet</div>'; return; }
  state.txs.slice().reverse().forEach((t,idx)=>{
    const el = document.createElement('div'); el.className='tx-card'; el.style.marginBottom='8px';
    const txhash = t.meta.txhash || '—';
    el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong class="mono">${t.type}</strong> <span class="tiny muted">${t.time.split('T')[1].slice(0,8)}</span></div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="ghost" data-copytx="${idx}">Copy</button>
        <button class="ghost" data-dl="${idx}">Download</button>
      </div>
    </div>
    <div class="tiny" style="margin-top:6px">${escapeHtml(t.summary)}</div>
    <div class="tiny muted" style="margin-top:8px">tx: <span class="mono">${txhash}</span></div>`;
    box.appendChild(el);
  });
  box.querySelectorAll('[data-copytx]').forEach(b=>b.onclick=()=>{ const i=b.getAttribute('data-copytx'); copyToClipboard(JSON.stringify(state.txs.slice().reverse()[i])); uiLog('Tx copied'); });
  box.querySelectorAll('[data-dl]').forEach(b=>b.onclick=()=>{ const i=b.getAttribute('data-dl'); const tx=state.txs.slice().reverse()[i]; downloadText(`tx-${i}.json`, JSON.stringify(tx,null,2)); uiLog('Tx downloaded'); });
}

// Merkle helper: full binary tree levels generator
function buildTreeLevels(leaves){
  if(!leaves.length) return [];
  let level = leaves.slice();
  const levels = [level.slice()];
  while(level.length>1){
    const next=[];
    for(let i=0;i<level.length;i+=2){
      const a = level[i]; const b = (i+1<level.length)? level[i+1] : level[i];
      next.push('(h)'); // placeholder; actual hash computed separately if needed
    }
    level = next;
    levels.unshift(level.slice()); // root on top (we'll invert later for nice render)
  }
  // We need to produce an array with leaves at index 0; easiest: compute all levels bottom-up:
  const bottomUp = [];
  level = leaves.slice();
  bottomUp.push(leaves.slice());
  let temp = leaves.slice();
  while(temp.length>1){
    const next = [];
    for(let i=0;i<temp.length;i+=2){
      const a=temp[i]; const b=(i+1<temp.length)?temp[i+1]:temp[i];
      next.push(hashConcatSync(a,b));
    }
    bottomUp.push(next);
    temp = next;
  }
  return bottomUp; // index 0=leaves, last=index root
}
// synchronous-ish placeholder hash (we use substring to simulate label)
function hashConcatSync(a,b){ return (a.slice(0,6)+'+'+b.slice(0,6)).slice(0,12); }

// highlight path for a chosen leaf index (visual)
function highlightPath(levelIndex, nodeIndex, levels){
  // levels: bottom-up array, levelIndex is index into levels (0=leaves)
  // we'll render the full tree and highlight nodes on the selected path
  const rows = document.querySelectorAll('#merkleViz .tree-row');
  rows.forEach((r,li)=>{
    const nodes = r.querySelectorAll('.node');
    nodes.forEach(n=> n.classList.remove('active'));
  });
  // simple path: leaf -> parent -> ... -> root
  let idx = nodeIndex;
  for(let li=0; li<levels.length; li++){
    const row = rows[li];
    if(!row) continue;
    const nodes = row.querySelectorAll('.node');
    const node = nodes[idx];
    if(node) node.classList.add('active');
    idx = Math.floor(idx/2);
  }
  uiLog(`Inspecting leaf #${nodeIndex} — path highlighted`);
}

// Merkle proof functions (real)
async function calcMerkleRoot(leaves){
  if(!leaves.length) return '';
  let level = leaves.slice();
  while(level.length>1){
    const next=[];
    for(let i=0;i<level.length;i+=2){
      const a=level[i]; const b=(i+1<level.length)?level[i+1]:level[i];
      next.push(await sha256Hex(a+b));
    }
    level = next;
  }
  return level[0];
}
async function makeMerkleProof(leaves,index){
  let idx=index; let level=leaves.slice(); const proof=[];
  while(level.length>1){
    const siblingIndex = (idx % 2 === 0) ? idx+1 : idx-1;
    const sibling = (siblingIndex < level.length) ? level[siblingIndex] : level[idx];
    proof.push({sibling, isLeft: (idx%2===1)});
    // next level
    const next=[];
    for(let i=0;i<level.length;i+=2){
      const a=level[i]; const b=(i+1<level.length)? level[i+1]: level[i];
      next.push(await sha256Hex(a+b));
    }
    level = next; idx = Math.floor(idx/2);
  }
  return proof;
}
async function verifyMerkleProof(leaf, proof, root, index){
  let computed = leaf; let idx = index;
  for(const step of proof){
    if(idx%2===0) computed = await sha256Hex(computed + (step.sibling||computed));
    else computed = await sha256Hex((step.sibling||computed) + computed);
    idx = Math.floor(idx/2);
  }
  return computed === root;
}

// Business logic (notes, deposit, withdraw)
const RATE = 1000;
async function createNoteForAmount(wAmount){
  const secret = randB64(32);
  const leaf = await sha256Hex(secret);
  return `${secret}:${leaf}:${wAmount}`;
}
async function deposit(amountBTC){
  amountBTC = Number(amountBTC);
  if(!amountBTC || amountBTC<=0){ uiLog('Invalid deposit amount','error'); return; }
  if(amountBTC > state.btcBalance){ uiLog('Insufficient mock BTC','error'); return; }
  const w = Number((amountBTC * RATE).toFixed(6));
  const note = await createNoteForAmount(w);
  state.notes.push(note); state.leaves.push(note.split(':')[1]);
  state.btcBalance = Number((state.btcBalance - amountBTC).toFixed(6));
  state.wBalance = Number((state.wBalance + w).toFixed(6));
  const tx = pushTx('DEPOSIT', `Deposited ${amountBTC} BTC → ${w} wSTRK. Note created.`, {noteId: state.notes.length-1});
  // auto-copy to clipboard if allowed
  try{ await navigator.clipboard.writeText(note); uiLog('Note copied to clipboard'); }catch(e){}
  save(); renderAll();
  return note;
}
function autoSelectNotes(amount){
  amount = Number(amount);
  const available = state.notes.map((n,idx)=>{const parts=n.split(':'); return {idx, note:n, leaf:parts[1], amt:Number(parts[2])};});
  available.sort((a,b)=>b.amt - a.amt);
  const picked=[]; let sum=0;
  for(const a of available){ if(sum>=amount) break; picked.push(a); sum+=a.amt; }
  if(sum < amount) return null; return {picked, sum};
}
async function withdrawWithNote(noteStr, dest, gasless=false){
  if(!noteStr){ uiLog('Note required','error'); return; }
  const parts = noteStr.split(':'); if(parts.length<3){ uiLog('Bad note format','error'); return; }
  const secret=parts[0], leaf=parts[1], amt=Number(parts[2]);
  const idx = state.leaves.indexOf(leaf);
  if(idx===-1){ uiLog('Note not found in pool (spent?)','error'); return; }
  const proof = await makeMerkleProof(state.leaves, idx);
  const root = await calcMerkleRoot(state.leaves);
  const nullifier = await sha256Hex('null:'+noteStr);
  if(state.nulls.includes(nullifier)){ uiLog('Nullifier already used','error'); return; }
  const ok = await verifyMerkleProof(leaf, proof, root, idx);
  if(!ok){ uiLog('Proof verification failed (client)','error'); return; }
  state.nulls.push(nullifier); state.leaves.splice(idx,1); const noteIdx = state.notes.indexOf(noteStr); if(noteIdx!==-1) state.notes.splice(noteIdx,1);
  state.wBalance = Number((state.wBalance - amt).toFixed(6));
  const tx = pushTx('WITHDRAW', `Withdraw ${amt} wSTRK → ${dest}. Gasless:${gasless}`, { nullifier, proofLen: proof.length });
  save(); renderAll();
  // Optional simulated on-chain marking (not automatic)
  return tx;
}
async function withdrawAmount(amount, dest, gasless=false){
  amount = Number(amount);
  if(isNaN(amount) || amount<=0){ uiLog('Invalid withdraw amount','error'); return; }
  if(amount > state.wBalance){ uiLog('Insufficient wrapped balance','error'); return; }
  const selection = autoSelectNotes(amount);
  if(!selection){ uiLog('Insufficient notes to cover amount','error'); return; }
  for(const p of selection.picked){
    const n = p.note; const nullifier = await sha256Hex('null:'+n); state.nulls.push(nullifier);
    const leaf = p.leaf; const li = state.leaves.indexOf(leaf); if(li!==-1) state.leaves.splice(li,1);
    const ni = state.notes.indexOf(n); if(ni!==-1) state.notes.splice(ni,1);
  }
  const sum = selection.sum; const change = Number((sum - amount).toFixed(6));
  if(change>0.000001){
    const cn = await createNoteForAmount(change); state.notes.push(cn); state.leaves.push(cn.split(':')[1]); uiLog(`Change note created: ${change} wSTRK`);
  }
  state.wBalance = Number((state.wBalance - amount).toFixed(6));
  pushTx('WITHDRAW', `Withdraw ${amount} wSTRK → ${dest} (used ${selection.picked.length} notes)`);
  save(); renderAll();
}

// Export / Import encrypted backup
async function exportEncrypted(password){
  if(!password){ uiLog('Password required','error'); return; }
  const enc = new TextEncoder(); const salt = crypto.getRandomValues(new Uint8Array(16));
  const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), {name:'PBKDF2'}, false, ['deriveKey']);
  const key = await crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:200000,hash:'SHA-256'}, keyMaterial, {name:'AES-GCM',length:256}, true, ['encrypt']);
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const data = new TextEncoder().encode(JSON.stringify(state));
  const ct = await crypto.subtle.encrypt({name:'AES-GCM',iv}, key, data);
  const payload = { s: btoa(String.fromCharCode(...salt)), i: btoa(String.fromCharCode(...iv)), c: btoa(String.fromCharCode(...new Uint8Array(ct))) };
  downloadText('bitshade_backup_enc.json', JSON.stringify(payload,null,2)); uiLog('Encrypted backup saved.');
}
async function importEncryptedFile(file,password){
  try{
    const txt = await file.text(); const payload = JSON.parse(txt);
    const salt = Uint8Array.from(atob(payload.s), c=>c.charCodeAt(0));
    const iv = Uint8Array.from(atob(payload.i), c=>c.charCodeAt(0));
    const ct = Uint8Array.from(atob(payload.c), c=>c.charCodeAt(0));
    const keyMaterial = await crypto.subtle.importKey('raw', new TextEncoder().encode(password), {name:'PBKDF2'}, false, ['deriveKey']);
    const key = await crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:200000,hash:'SHA-256'}, keyMaterial, {name:'AES-GCM',length:256}, true, ['decrypt']);
    const data = await crypto.subtle.decrypt({name:'AES-GCM',iv}, key, ct);
    const obj = JSON.parse(new TextDecoder().decode(data)); state = obj; save(); renderAll(); uiLog('Encrypted backup imported successfully.');
  }catch(e){ uiLog('Import failed: '+(e.message||e),'error'); }
}

// Small helpers
function downloadText(filename, text){ const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([text],{type:'text/plain'})); a.download=filename; document.body.appendChild(a); a.click(); a.remove(); }
function showRevealModal(note){ $('revealText').textContent = note; $('noteRevealModal').style.display='flex'; }
function hideRevealModal(){ $('noteRevealModal').style.display='none'; }
function showConfirm(msg, okCb){ $('confirmText').textContent = msg; $('confirmModal').style.display='flex'; const ok = ()=>{ $('confirmModal').style.display='none'; okCb && okCb(); cleanup(); }; const cancel = ()=>{ $('confirmModal').style.display='none'; cleanup(); }; function cleanup(){ $('confirmOk').onclick=null; $('confirmCancel').onclick=null; } $('confirmOk').onclick = ok; $('confirmCancel').onclick = cancel; }

// Mode & tutorial
let mode = 'beginner'; // or 'advanced'
$('modeBegin').onclick = ()=>{ mode='beginner'; renderAll(); }
$('modeAdv').onclick = ()=>{ mode='advanced'; renderAll(); }
function renderModeHelp(){ $('modeHelp').textContent = 'Mode: ' + (mode==='beginner'?'Beginner — guided tour':'Advanced — technical inspector'); renderTour(); }

// Tutorial content generator
let tourStep = 0;
function renderTour(){
  const container = $('tourContent'); container.innerHTML = '';
  if(mode==='beginner'){
    const steps = [
      {title:'Step 1 — Deposit', text:'Enter a small BTC amount (e.g. 0.01) and click Deposit. A private note is created and stored locally.'},
      {title:'Step 2 — Inspect pool', text:'Open Pool Inspector to see the Merkle root and the leaves representing notes.'},
      {title:'Step 3 — Withdraw', text:'Paste your note into Withdraw and click Withdraw to spend it. The app prevents double-spend using nullifiers.'},
      {title:'Step 4 — Backup', text:'Export an encrypted backup to restore your notes on another device.'}
    ];
    const s = steps[tourStep] || steps[0];
    container.innerHTML = `<div class="help-step"><strong>${s.title}</strong><div style="height:6px"></div><div class="tiny muted">${s.text}</div></div>
      <div style="display:flex;gap:8px;justify-content:flex-end"><button class="ghost" id="tourPrev">Prev</button> <button id="tourNext">Next</button></div>`;
    $('tourPrev').onclick = ()=>{ tourStep = Math.max(0,tourStep-1); renderTour(); };
    $('tourNext').onclick = ()=>{ tourStep = Math.min(3,tourStep+1); renderTour(); };
  } else {
    container.innerHTML = `<div class="help-step"><strong>Advanced Inspector</strong><div style="height:6px"></div><div class="tiny muted">Use the Merkle visualizer to inspect proofs. Click a leaf to highlight the proof path. Use Verify proof to see client-side verification details.</div></div>
      <div class="studio">
        <div class="tx-card"><strong>Technical Notes</strong><ul class="tiny muted"><li>Notes: secret || leaf = sha256(secret)</li><li>Merkle: binary hash( left || right ) using SHA-256</li><li>Nullifier = sha256('null:'+note)</li></ul></div>
        <div class="tx-card"><strong>Developer</strong><div class="tiny muted">Pack SHA-256 → felt by truncation when sending to on-chain verifiers. See README for exact packing.</div></div>
      </div>`;
  }
}

// Fake "sync to chain" (simulated)
$('btnSyncRootOnChain').onclick = async ()=>{
  const root = await calcMerkleRoot(state.leaves);
  if(!root){ uiLog('No root to sync','error'); return; }
  const txhash = fakeTxHash();
  pushTx('SYNC', `Synced root to chain (sim): ${root.substr(0,12)}...`, { txhash, root });
  $('onchainStatus').textContent = `Synced (sim) — tx ${txhash}`;
  // in real setup: call syncRootToChain(rootFelt)
};

// "Check on-chain" simulation -> just reads our saved last SYNC tx
$('btnCheckOnChain').onclick = async ()=>{
  const last = state.txs.slice().reverse().find(t=>t.type==='SYNC');
  if(!last){ uiLog('No on-chain sync found (sim)','error'); return; }
  $('onchainStatus').textContent = `on-chain root (sim): ${last.meta.root.substr(0,12)}... tx:${last.meta.txhash}`;
  uiLog('Checked on-chain root (sim)');
};

// UI wiring for deposit/withdraw
$('depositPreset').onchange = ()=>$('depositAmount').value = $('depositPreset').value;
$('btnDeposit').onclick = async ()=>{ const amt=$('depositAmount').value||'0.01'; await deposit(amt); uiLog('Deposit completed'); };
$('btnBatchDeposit').onclick = async ()=>{ for(let i=0;i<3;i++){ await deposit(0.01); await new Promise(r=>setTimeout(r,220)); } uiLog('Batch deposit completed'); };
$('btnAutoSelect').onclick = ()=>{ const amt=Number($('withdrawAmount').value||0); if(!amt){ uiLog('Enter withdraw amount first','error'); return; } const selected=autoSelectNotes(amt); if(!selected){ uiLog('Auto-select failed','error'); return; } const list = selected.picked.map(p=>`#${p.idx} ${p.amt}`).join(', '); $('notesForSelect').innerHTML = `<div class="tiny muted">selected: ${list}</div>`; uiLog('Notes auto-selected: '+list); };
$('btnWithdraw').onclick = async ()=>{ const note=$('noteInput').value.trim(); const amt=$('withdrawAmount').value; const dest=$('destAddr').value||'dst_mock'; const gasless=$('checkboxGasless').checked; if(note){ await withdrawWithNote(note,dest,gasless); return; } if(!amt){ uiLog('Enter withdraw amount or paste a note','error'); return; } await withdrawAmount(amt,dest,gasless); }
$('btnVerifyProof').onclick = async ()=>{ const pasted = $('noteInput').value.trim(); if(!pasted){ uiLog('Paste a note to verify','error'); return; } const parts=pasted.split(':'); const leaf = parts[1]; const idx = state.leaves.indexOf(leaf); if(idx===-1){ uiLog('Leaf not in pool','error'); return; } const proof = await makeMerkleProof(state.leaves, idx); const root = await calcMerkleRoot(state.leaves); const ok = await verifyMerkleProof(leaf, proof, root, idx); uiLog('Proof verify: '+(ok?'OK':'FAILED')); uiLog(`Proof steps: ${proof.length}`); };

// Demo run, reset, export/import
$('btnDemoRun').onclick = async ()=>{ uiLog('Demo run started'); const n = await deposit(0.02); await new Promise(r=>setTimeout(r,300)); await withdrawWithNote(n,'0xDEMO',true); uiLog('Demo run completed'); };
$('btnReset').onclick = ()=>{ if(confirm('Reset demo and clear local state?')){ localStorage.removeItem(KEY); state={btcBalance:0.5,wBalance:0,notes:[],leaves:[],nulls:[],txs:[]}; save(); renderAll(); uiLog('Demo reset'); } };
$('btnExportEnc').onclick = async ()=>{ const pw=prompt('Enter password for encrypted export (strong):'); if(!pw) return; await exportEncrypted(pw); };
$('btnImportEnc').onclick = ()=>{ const f=document.createElement('input'); f.type='file'; f.accept='.json'; f.onchange = e=>{ const file=e.target.files[0]; const pw=prompt('Enter password to decrypt:'); if(!pw) return; importEncryptedFile(file,pw); }; f.click(); };

// Reveal modal
$('revealCancel').onclick = hideRevealModal;
$('revealCopy').onclick = ()=>{ copyToClipboard($('revealText').textContent); uiLog('Note copied'); };

// Confirm modal (used by future actions)
$('confirmCancel').onclick = ()=>$('confirmModal').style.display='none';

// Reveal Glock modal
$('btnGlockInfo').onclick = ()=>$('glockModal').style.display='flex';
$('btnGlockClose').onclick = ()=>$('glockModal').style.display='none';

// confirm modal usage example:
// showConfirm('This will reset state. Continue?', ()=>{ /* confirmed action */ });

// note reveal modal is shown by "Reveal" buttons
// helper for downloads and copy implemented above

// small helper: show a sample tx with proof JSON (for judges)
$('btnShowTx').onclick = async ()=>{
  const last = state.txs.slice().reverse()[0];
  if(!last){ uiLog('No txs yet to show','error'); return; }
  const fakeJson = { txhash: last.meta.txhash || fakeTxHash(), type: last.type, time: last.time, summary: last.summary, meta:last.meta };
  downloadText('proof_sample.json', JSON.stringify(fakeJson,null,2));
  uiLog('Sample proof JSON downloaded');
};

// note reveal modal copy
$('revealCopy').onclick = ()=>{ copyToClipboard($('revealText').textContent); uiLog('Note copied to clipboard'); };

// simple utility to show tx JSON (simulate on-chain proof download)
function downloadProofForLast(){
  const last = state.txs.slice().reverse()[0];
  if(!last) return;
  const obj = {type:last.type,time:last.time,summary:last.summary,meta:last.meta};
  downloadText('proof.json', JSON.stringify(obj,null,2));
}

// document init
renderAll();

</script>
</body>
</html>
