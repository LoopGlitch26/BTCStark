<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>BitShade-Pro — Private BTC → Starknet Bridge</title>
<meta name="description" content="BitShade-Pro: Private BTC → Starknet bridge — Merkle proofs, nullifiers, encrypted backups.">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#06121a; --panel:#0a1929; --panel-hover:#0d1f33; --muted:#9fb0c6;
    --accent:#7c5cff; --accent-2:#4f46e5; --accent-glow:rgba(124,92,255,0.25);
    --glass:rgba(255,255,255,0.02); --glass-2:rgba(255,255,255,0.04);
    --card-shadow: 0 8px 32px rgba(2,6,23,0.7), 0 0 0 1px rgba(255,255,255,0.02);
    --ok:#16a34a; --bad:#ef4444; --warning:#f59e0b;
  }
  *{box-sizing:border-box}
  html,body{height:100%;overflow-x:hidden}
  body{
    font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Arial;
    margin:0;
    background:radial-gradient(ellipse at top, #0f1f2f 0%, #02121a 50%, #000 100%);
    color:#e6eef8;
    padding:20px;
    line-height:1.45;
    position:relative;
  }

  .wrap{max-width:1400px;margin:0 auto;position:relative;z-index:1}

  header{
    background:linear-gradient(135deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    backdrop-filter:blur(18px);
    border:1px solid rgba(255,255,255,0.05);
    border-radius:14px;
    padding:20px;
    margin-bottom:20px;
    box-shadow:0 8px 32px rgba(0,0,0,0.3);
  }

  .header-content{display:flex;align-items:center;justify-content:space-between;gap:20px;position:relative;z-index:1}
  .header-left{flex:1}
  h1{
    margin:0 0 6px;
    font-size:28px;
    font-weight:800;
    background:linear-gradient(135deg, #fff 0%, #a78bfa 100%);
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    background-clip:text;
  }
  .lead{margin:0 0 8px;color:var(--muted);font-size:14px}
  .tech-stack{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .tech-badge{
    padding:4px 10px;border-radius:999px;background:rgba(124,92,255,0.08);
    border:1px solid rgba(124,92,255,0.12);font-size:11px;font-weight:600;color:#cdb6ff;
  }

  .top-stats{display:flex;gap:12px;align-items:stretch}
  .stat{
    background:linear-gradient(135deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    padding:12px;border-radius:10px;min-width:120px;text-align:center;
    border:1px solid rgba(255,255,255,0.04);
  }
  .stat .small{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:6px}
  .stat .big{font-weight:700;font-family:'JetBrains Mono',monospace;font-size:18px;color:#fff}

  .mode-selector{display:flex;gap:8px;background:rgba(0,0,0,0.25);padding:6px;border-radius:10px}
  .mode-btn{background:transparent;border:0;padding:8px 14px;border-radius:8px;color:var(--muted);cursor:pointer;font-weight:600}
  .mode-btn.active{background:linear-gradient(135deg,var(--accent-2),var(--accent));color:#fff;box-shadow:0 4px 12px var(--accent-glow)}

  .grid{display:grid;grid-template-columns:1fr 460px;gap:20px}

  .card{background:linear-gradient(135deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));border-radius:12px;padding:16px;border:1px solid rgba(255,255,255,0.04);box-shadow:var(--card-shadow)}
  .card-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  h3{margin:0;font-size:18px;font-weight:700}
  .card-subtitle{font-size:13px;color:var(--muted);margin-top:6px}

  button{background:linear-gradient(135deg,var(--accent-2),var(--accent));border:0;color:#fff;padding:10px 16px;border-radius:10px;cursor:pointer;font-weight:700}
  button.ghost{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  input,textarea,select{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.08);background:rgba(0,0,0,0.28);color:inherit}

  .mono{font-family:'JetBrains Mono',monospace}
  .small{font-size:13px;color:var(--muted)}
  .tiny{font-size:12px;color:var(--muted)}

  .merkle-canvas{background:linear-gradient(135deg, rgba(124,92,255,0.04), rgba(79,70,229,0.03));padding:14px;border-radius:10px;border:1px solid rgba(124,92,255,0.08)}
  .root-display{background:linear-gradient(135deg, #667eea, #764ba2);padding:12px;border-radius:8px;color:#fff;margin:10px 0}
  .root-value{font-family:'JetBrains Mono',monospace;font-size:13px;word-break:break-all}

  .tree-row{display:flex;gap:12px;justify-content:center;padding:10px 0}
  .node{display:inline-flex;align-items:center;justify-content:center;padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);font-family:'JetBrains Mono',monospace}
  .node.leaf{background:linear-gradient(135deg,#072a36,#08364a);border-color:rgba(8,54,74,0.6)}
  .node.root{background:linear-gradient(135deg,#243bff,#7c5cff);font-weight:700;color:#fff}

  .log{height:220px;overflow:auto;background:rgba(0,0,0,0.35);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04)}
  .tx-card{padding:12px;border-radius:10px;background:linear-gradient(135deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));margin-bottom:10px}

  .note-card{padding:10px;border-radius:10px;background:rgba(0,0,0,0.28);border:1px solid rgba(255,255,255,0.04);margin-bottom:10px}
  .onboard-check{display:flex;align-items:center;gap:12px;padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.04);margin-bottom:8px}
  .checkbox-custom{width:18px;height:18px;border-radius:4px;border:2px solid rgba(255,255,255,0.14);display:inline-flex;align-items:center;justify-content:center}
  .checkbox-custom.checked{background:linear-gradient(135deg,var(--accent-2),var(--accent));border-color:var(--accent)}

  .modal-backdrop{display:none;position:fixed;inset:0;background:rgba(2,6,23,0.85);backdrop-filter:blur(8px);align-items:center;justify-content:center;padding:24px;z-index:1000}
  .modal-content{max-width:700px;width:100%;background:linear-gradient(135deg,rgba(10,25,41,0.98),rgba(6,18,26,0.98));border-radius:12px;padding:18px;border:1px solid rgba(124,92,255,0.12)}

  footer{margin-top:28px;padding:20px;text-align:center;color:var(--muted);font-size:13px;border-top:1px solid rgba(255,255,255,0.04)}
  @media (max-width:1100px){ .grid{grid-template-columns:1fr} .header-content{flex-direction:column;align-items:flex-start} }
</style>
</head>
<body>
<div class="wrap">

  <!-- Security banner -->
  <div class="card" style="margin-bottom:16px;background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
      <div>
        <strong style="font-size:14px">Security notice</strong>
        <div class="small" style="margin-top:6px">
          Notes (the secrets that can spend funds) are kept in memory only. Export an encrypted backup if you want persistence.
          Do not share your notes or backups. The app will not persist secrets to localStorage unless you explicitly export them.
        </div>
      </div>
      <div>
        <button class="ghost" id="btnAcknowledge">I understand</button>
      </div>
    </div>
  </div>

  <header>
    <div class="header-content">
      <div class="header-left">
        <h1>BitShade-Pro</h1>
        <p class="lead">
          Private, non-custodial BTC → Starknet bridge with Merkle proofs, nullifier protection, and encrypted backup support.
        </p>
        <div class="tech-stack">
          <span class="tech-badge">SHA-256 Merkle Trees</span>
          <span class="tech-badge">UTXO Privacy Model</span>
          <span class="tech-badge">Nullifier Registry</span>
          <span class="tech-badge">AES-GCM + PBKDF2</span>
          <span class="tech-badge">Starknet Integration</span>
        </div>
      </div>

      <div style="display:flex;flex-direction:column;gap:12px">
        <div class="top-stats">
          <div class="stat">
            <div class="small">BTC Balance</div>
            <div class="big mono" id="btcBal">0.500000</div>
          </div>
          <div class="stat">
            <div class="small">wSTRK</div>
            <div class="big mono" id="wBal">0.0000</div>
          </div>
          <div class="stat">
            <div class="small">Privacy Pool</div>
            <div class="big mono" id="poolSize">0</div>
          </div>
        </div>

        <div class="mode-selector">
          <button class="mode-btn active" id="modeBegin">Beginner</button>
          <button class="mode-btn" id="modeAdv">Advanced</button>
        </div>
      </div>
    </div>
  </header>

  <div class="grid">
    <main>
      <!-- Onboarding -->
      <section class="card" style="margin-bottom:16px">
        <div class="card-header">
          <div>
            <h3>Quick start</h3>
            <div class="card-subtitle">Follow these steps to create a private note and withdraw it. Backups are encrypted and manual.</div>
          </div>
          <button class="ghost" id="btnSkipOnboard">Skip</button>
        </div>

        <div id="onboardChecks"></div>

        <div style="display:flex;gap:12px;margin-top:12px">
          <div style="flex:1">
            <div class="note-card">
              <div class="small">Deposits</div>
              <div class="big mono" id="statsDeposits">0</div>
            </div>
          </div>
          <div style="flex:1">
            <div class="note-card">
              <div class="small">Withdrawals</div>
              <div class="big mono" id="statsWithdraws">0</div>
            </div>
          </div>
          <div style="flex:1">
            <div class="note-card">
              <div class="small">Proofs generated</div>
              <div class="big mono" id="statsProofs">0</div>
            </div>
          </div>
        </div>
      </section>

      <!-- Deposit -->
      <section class="card" style="margin-bottom:16px">
        <div class="card-header">
          <div>
            <h3>Deposit — Bridge BTC to Starknet</h3>
            <div class="card-subtitle">Create a privacy-preserving note. The note secret is required to spend later.</div>
          </div>
        </div>

        <div style="display:flex;gap:10px;align-items:flex-end;margin-bottom:12px">
          <div style="flex:1">
            <label class="small">Amount (BTC)</label>
            <input id="depositAmount" placeholder="0.01" type="number" step="0.001"/>
          </div>

          <select id="depositPreset" style="flex:0 0 140px">
            <option value="">Quick select</option>
            <option value="0.01">0.01</option>
            <option value="0.05">0.05</option>
            <option value="0.1">0.1</option>
          </select>
        </div>

        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="btnDeposit">Create private note</button>
          <button class="ghost" id="btnBatchDeposit">Batch (3 × 0.01)</button>
          <button class="ghost" id="btnExportEnc">Export encrypted backup</button>
          <button class="ghost" id="btnImportEnc">Import encrypted backup</button>
        </div>

        <div style="margin-top:12px;padding:10px;border-radius:8px;background:rgba(124,92,255,0.04);border:1px solid rgba(124,92,255,0.06);">
          <div class="small">Technical: secrets generated with the Web Crypto API. Notes => SHA-256 leaf. Backups use AES-GCM; PBKDF2 iterations=200000.</div>
        </div>
      </section>

      <!-- Withdraw -->
      <section class="card" style="margin-bottom:16px">
        <div class="card-header">
          <div>
            <h3>Withdraw — Spend private notes</h3>
            <div class="card-subtitle">Construct a Merkle inclusion proof and emit a nullifier to prevent double-spend.</div>
          </div>
        </div>

        <div style="display:grid;grid-template-columns:1fr 260px;gap:12px">
          <div>
            <label class="small">Paste note (optional)</label>
            <textarea id="noteInput" rows="2" placeholder="secret:leaf:amount"></textarea>

            <label class="small" style="margin-top:10px">Amount (wSTRK)</label>
            <input id="withdrawAmount" placeholder="0.0" type="number" step="0.01"/>

            <label class="small" style="margin-top:10px">Destination address</label>
            <input id="destAddr" placeholder="0x..." value="0xDEADBEEF"/>

            <div style="display:flex;align-items:center;gap:8px;margin:12px 0">
              <input type="checkbox" id="checkboxGasless"/>
              <span class="small">Use paymaster (gasless)</span>
            </div>

            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btnAutoSelect">Auto-select notes</button>
              <button id="btnWithdraw">Execute withdrawal</button>
              <button class="ghost" id="btnVerifyProof">Verify proof</button>
              <button class="ghost" id="btnShowTx">Export proof JSON</button>
            </div>

            <div id="withdrawNote" class="tiny" style="margin-top:12px;color:var(--muted)"></div>
          </div>

          <div>
            <div style="margin-bottom:10px">
              <div class="small">Selected notes</div>
            </div>
            <div id="notesForSelect" style="max-height:260px;overflow:auto;font-size:13px" class="mono"></div>
          </div>
        </div>
      </section>

      <!-- Activity -->
      <section class="card" style="margin-bottom:16px">
        <div class="card-header">
          <div>
            <h3>Activity & receipts</h3>
            <div class="card-subtitle">Chronological activity, click a transaction to expand details. Export proofs for audit.</div>
          </div>
        </div>
        <div id="txLog" class="log"></div>
      </section>
    </main>

    <!-- Right column: inspector, notes, nullifiers -->
    <aside>
      <section class="card" style="margin-bottom:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <h3 style="margin:0">Pool inspector</h3>
          <div class="small">Merkle leaves (SHA-256)</div>
        </div>

        <div style="margin-top:12px" class="merkle-canvas">
          <div class="root-display">
            <div class="small">Current root</div>
            <div class="root-value mono" id="root">—</div>
          </div>

          <div class="small" style="margin-bottom:8px">Pool size: <span id="poolCount">0</span></div>
          <div id="merkleViz"></div>

          <div style="display:flex;gap:8px;margin-top:12px">
            <button id="btnSyncRootOnChain">Sync root → Starknet (demo)</button>
            <button class="ghost" id="btnCheckOnChain">Check on-chain root</button>
          </div>

          <div id="onchainStatus" class="tiny" style="margin-top:8px;color:var(--muted)"></div>
        </div>
      </section>

      <section class="card" style="margin-bottom:12px">
        <h3 style="margin:0 0 10px">My notes</h3>
        <div class="small" style="margin-bottom:8px">Notes are session-only unless exported encrypted.</div>
        <div id="myNotes"></div>
      </section>

      <section class="card" style="margin-bottom:12px">
        <h3 style="margin:0 0 10px">Nullifiers (spent)</h3>
        <div id="nulls" class="mono tiny" style="max-height:140px;overflow:auto;color:var(--muted)"></div>
      </section>
    </aside>
  </div>

  <footer>
    BitShade-Pro — Non-custodial, privacy-minded BTC → Starknet UX. Built for secure, auditable transfers.
  </footer>
</div>

<!-- Modals -->
<div id="confirmModal" class="modal-backdrop" aria-hidden="true">
  <div class="modal-content">
    <div id="confirmText" class="small"></div>
    <div style="margin-top:12px;display:flex;justify-content:flex-end;gap:8px">
      <button class="ghost" id="confirmCancel">Cancel</button>
      <button id="confirmOk">Confirm</button>
    </div>
  </div>
</div>

<div id="revealModal" class="modal-backdrop" aria-hidden="true">
  <div class="modal-content">
    <h3 style="margin-top:0">Reveal note</h3>
    <div class="small" style="color:var(--muted)">Anyone who obtains this note can spend the funds.</div>
    <pre id="revealText" style="margin-top:12px;background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;overflow:auto"></pre>
    <div style="margin-top:12px;display:flex;justify-content:flex-end;gap:8px">
      <button class="ghost" id="revealClose">Close</button>
      <button id="revealCopy">Copy</button>
    </div>
  </div>
</div>

<script>
/* BitShade-Pro — full single-file client prototype
   - No external dependencies
   - Security: notes kept session-only; only public state persisted (balances, leaves, nulls, txs)
   - Hash adapter with SHA-256 and Poseidon placeholder
*/

// -----------------------------
// Hash adapter (sha256 + placeholder for Poseidon)
// -----------------------------
async function sha256Hex(text) {
  const enc = new TextEncoder();
  const data = enc.encode(text);
  const h = await crypto.subtle.digest('SHA-256', data);
  const bytes = new Uint8Array(h);
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}
// Poseidon placeholder: deterministic fallback using sha256; replace with real Poseidon lib for on-chain parity.
async function poseidonHashPlaceholder(inputs) {
  const s = Array.isArray(inputs) ? inputs.join('|') : String(inputs);
  return await sha256Hex(s);
}
const hashAdapter = { sha256Hex, poseidonHashPlaceholder };

// -----------------------------
// Small UI sanitizer to remove emojis and odd glyphs from labels (non-invasive)
// -----------------------------
function stripEmojisFromText(s) {
  if (!s) return s;
  return s.replace(/([\u2700-\u27BF]|[\uE000-\uF8FF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|\uFE0F|\u200D)/g,'').trim();
}
function sanitizeUIStrings() {
  document.querySelectorAll('h1,h2,h3,button,label,option').forEach(el => {
    if (el && el.textContent) {
      const cleaned = stripEmojisFromText(el.textContent);
      if (cleaned !== el.textContent) el.textContent = cleaned;
    }
  });
}
sanitizeUIStrings();
window.addEventListener('load', sanitizeUIStrings);

// -----------------------------
// Public-state persistence (only non-secret data)
// -----------------------------
const PUBLIC_KEY = 'bitshade_pro_public_v1';
function savePublicState() {
  try {
    const pub = {
      btcBalance: state.btcBalance,
      wBalance: state.wBalance,
      leaves: state.leaves,
      nulls: state.nulls,
      txs: state.txs
    };
    localStorage.setItem(PUBLIC_KEY, JSON.stringify(pub));
  } catch (e) {
    console.warn('savePublicState failed', e);
  }
}
function loadPublicState() {
  try {
    const raw = localStorage.getItem(PUBLIC_KEY);
    if (!raw) return;
    const s = JSON.parse(raw);
    state.btcBalance = s.btcBalance ?? state.btcBalance;
    state.wBalance = s.wBalance ?? state.wBalance;
    state.leaves = s.leaves ?? state.leaves;
    state.nulls = s.nulls ?? state.nulls;
    state.txs = s.txs ?? state.txs;
  } catch (e) {
    console.warn('loadPublicState failed', e);
  }
}

// -----------------------------
// Utilities & general state
// -----------------------------
const $ = id => document.getElementById(id);
const nowISO = () => new Date().toISOString();
function buf2hex(buffer) { const bytes = new Uint8Array(buffer); return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join(''); }
function randB64(len=32){
  const a = crypto.getRandomValues(new Uint8Array(len));
  let s = '';
  for (let i=0;i<a.length;i++) s += String.fromCharCode(a[i]);
  return btoa(s);
}
function fakeTxHash(){
  const r = crypto.getRandomValues(new Uint8Array(16));
  return '0x' + Array.from(r).map(b=>b.toString(16).padStart(2,'0')).join('');
}
function downloadText(filename, text){ const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([text], { type: 'application/json' })); a.download = filename; document.body.appendChild(a); a.click(); a.remove(); }
function copyToClipboard(text){ return navigator.clipboard?.writeText(text).then(()=>uiLog('Copied to clipboard')).catch(()=>{}); }

// -----------------------------
// Application state
// -----------------------------
let state = {
  btcBalance: 0.5,
  wBalance: 0.0,
  notes: [],   // secret:leaf:amount (kept in memory only)
  leaves: [],
  nulls: [],
  txs: []
};
loadPublicState(); // load persisted public state

// -----------------------------
// UI logging & transactions
// -----------------------------
function uiLog(msg, level='info'){
  const el = document.createElement('div');
  el.innerHTML = `<div style="display:flex;justify-content:space-between"><div><strong class="mono small">${(new Date()).toLocaleTimeString()}</strong> — ${escapeHtml(msg)}</div></div>`;
  if (level === 'error') el.style.color = 'var(--bad)';
  $('txLog').prepend(el);
}
function pushTx(type, summary, meta = {}){
  const tx = { type, time: nowISO(), summary, meta: { ...meta, txhash: meta.txhash || fakeTxHash() } };
  state.txs.push(tx);
  savePublicState();
  renderTxs();
  uiLog(`${type}: ${summary}`);
  return tx;
}
function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;'); }

// -----------------------------
// Renderers
// -----------------------------
function renderAll(){
  $('btcBal').textContent = toFixed(state.btcBalance,6);
  $('wBal').textContent = toFixed(state.wBalance,4);
  $('poolSize').textContent = state.leaves.length;
  renderNotes();
  renderLeaves();
  renderNulls();
  renderRoot();
  renderTxs();
  renderOnboard();
}
function toFixed(n,d=6){ return Number(n).toFixed(d); }

function renderNotes(){
  const box = $('myNotes');
  box.innerHTML = '';
  if (state.notes.length === 0) { box.innerHTML = '<div class="small" style="color:var(--muted)">No notes stored (session only). Export encrypted backup to persist.</div>'; return; }
  state.notes.forEach((n, idx) => {
    const [secret, leaf, amt] = n.split(':');
    const div = document.createElement('div'); div.className = 'note-card';
    div.innerHTML = `<div class="mono">${leaf.slice(0,16)}... — <span class="small">${amt} wSTRK</span></div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button class="ghost" data-copy="${idx}">Copy</button>
        <button class="ghost" data-reveal="${idx}">Reveal</button>
        <button class="ghost" data-dl="${idx}">Download</button>
      </div>`;
    box.appendChild(div);
  });
  box.querySelectorAll('[data-copy]').forEach(b => b.onclick = () => {
    const i = Number(b.getAttribute('data-copy')); copyToClipboard(state.notes[i]); uiLog('Note copied to clipboard');
  });
  box.querySelectorAll('[data-dl]').forEach(b => b.onclick = () => {
    const i = Number(b.getAttribute('data-dl')); downloadText(`note-${i}.txt`, state.notes[i]); uiLog('Note downloaded');
  });
  box.querySelectorAll('[data-reveal]').forEach(b => b.onclick = () => {
    const i = Number(b.getAttribute('data-reveal')); showRevealModal(state.notes[i]);
  });
}

function renderLeaves(){
  const box = $('merkleViz');
  box.innerHTML = '';
  if (!state.leaves.length) { box.innerHTML = '<div class="small" style="color:var(--muted)">No leaves in pool</div>'; return; }
  const levels = buildTreeLevels(state.leaves);
  levels.forEach((lvl, li) => {
    const row = document.createElement('div'); row.className = 'tree-row';
    lvl.forEach((node, i) => {
      const nd = document.createElement('div'); nd.className = 'node ' + (li === 0 ? 'leaf' : (li === levels.length-1 ? 'root' : ''));
      nd.textContent = node.slice(0,10) + (node.length>10 ? '...' : '');
      nd.onclick = () => highlightPath(li, i, levels);
      row.appendChild(nd);
    });
    box.appendChild(row);
  });
}

async function renderRoot(){
  const r = await calcMerkleRoot(state.leaves);
  $('root').textContent = r || '—';
  $('poolCount').textContent = state.leaves.length;
}

function renderNulls(){
  const el = $('nulls'); el.innerHTML = '';
  if (!state.nulls.length) { el.innerHTML = '<div class="small" style="color:var(--muted)">None</div>'; return; }
  state.nulls.forEach(n => {
    const d = document.createElement('div'); d.textContent = n.slice(0,16) + '...'; el.appendChild(d);
  });
}

function renderTxs(){
  const box = $('txLog'); box.innerHTML = '';
  if (!state.txs.length){ box.innerHTML = '<div class="small" style="color:var(--muted)">No activity yet</div>'; return; }
  state.txs.slice().reverse().forEach((t, i) => {
    const el = document.createElement('div'); el.className = 'tx-card';
    el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong class="mono">${t.type}</strong> <span class="small" style="color:var(--muted)">${t.time.split('T')[1].slice(0,8)}</span></div>
      <div style="display:flex;gap:8px">
        <button class="ghost" data-copytx="${i}">Copy</button>
        <button class="ghost" data-dltx="${i}">Download</button>
      </div>
    </div>
    <div class="small" style="margin-top:8px">${escapeHtml(t.summary)}</div>
    <div class="small" style="margin-top:8px;color:var(--muted)">tx: <span class="mono">${t.meta.txhash}</span></div>`;
    box.appendChild(el);
  });
  box.querySelectorAll('[data-copytx]').forEach(b => b.onclick = () => {
    const i = Number(b.getAttribute('data-copytx')); copyToClipboard(JSON.stringify(state.txs.slice().reverse()[i])); uiLog('Tx copied');
  });
  box.querySelectorAll('[data-dltx]').forEach(b => b.onclick = () => {
    const i = Number(b.getAttribute('data-dltx')); const tx = state.txs.slice().reverse()[i]; downloadText(`tx-${i}.json`, JSON.stringify(tx,null,2)); uiLog('Tx downloaded');
  });
}

// -----------------------------
// Merkle tree helpers (sha256-based)
// -----------------------------
async function calcMerkleRoot(leaves){
  if (!leaves.length) return '';
  let level = leaves.slice();
  while (level.length > 1){
    const next = [];
    for (let i=0;i<level.length;i+=2){
      const a = level[i];
      const b = (i+1<level.length) ? level[i+1] : level[i];
      next.push(await hashAdapter.sha256Hex(a + b));
    }
    level = next;
  }
  return level[0];
}
async function makeMerkleProof(leaves, index){
  let idx = index; let level = leaves.slice(); const proof = [];
  while (level.length > 1){
    const siblingIndex = (idx % 2 === 0) ? idx + 1 : idx - 1;
    const sibling = (siblingIndex < level.length) ? level[siblingIndex] : level[idx];
    proof.push({ sibling, isLeft: (idx % 2 === 1) });
    // build next
    const next = [];
    for (let i=0;i<level.length;i+=2){
      const a = level[i]; const b = (i+1<level.length) ? level[i+1] : level[i];
      next.push(await hashAdapter.sha256Hex(a + b));
    }
    level = next; idx = Math.floor(idx/2);
  }
  return proof;
}
async function verifyMerkleProof(leaf, proof, root, index){
  let computed = leaf; let idx = index;
  for (const step of proof){
    if (idx % 2 === 0) computed = await hashAdapter.sha256Hex(computed + (step.sibling || computed));
    else computed = await hashAdapter.sha256Hex((step.sibling || computed) + computed);
    idx = Math.floor(idx/2);
  }
  return computed === root;
}

function buildTreeLevels(leaves){
  if (!leaves.length) return [];
  const levels = [];
  let level = leaves.slice();
  levels.push(level.slice());
  while (level.length > 1){
    const next = [];
    for (let i=0;i<level.length;i+=2){
      const a = level[i]; const b = (i+1<level.length)?level[i+1]:level[i];
      next.push((a.slice(0,8) + '+' + b.slice(0,8)).slice(0,16));
    }
    level = next; levels.push(level.slice());
  }
  return levels;
}

function highlightPath(levelIndex, nodeIndex, levels){
  // simple visual highlight: re-render and then add active class to nodes
  const rows = document.querySelectorAll('#merkleViz .tree-row');
  rows.forEach(r => r.querySelectorAll('.node').forEach(n => n.classList.remove('active')));
  let idx = nodeIndex;
  for (let li=0; li<levels.length; li++){
    const row = rows[li]; if (!row) continue;
    const nodes = row.querySelectorAll('.node');
    const node = nodes[idx]; if (node) node.classList.add('active');
    idx = Math.floor(idx/2);
  }
  uiLog(`Inspecting leaf #${nodeIndex}`);
}

// -----------------------------
// Business logic: create notes, deposit, withdraw
// -----------------------------
const RATE = 1000; // wSTRK per BTC for demo purposes
async function createNoteForAmount(wAmount){
  const secret = randB64(32);
  const leaf = await hashAdapter.sha256Hex(secret);
  return `${secret}:${leaf}:${wAmount}`;
}
async function deposit(amountBTC){
  amountBTC = Number(amountBTC);
  if (!amountBTC || amountBTC <= 0) { uiLog('Invalid deposit amount', 'error'); return null; }
  if (amountBTC > state.btcBalance) { uiLog('Insufficient BTC', 'error'); return null; }
  const w = Number((amountBTC * RATE).toFixed(6));
  const note = await createNoteForAmount(w);
  state.notes.push(note);
  state.leaves.push(note.split(':')[1]);
  state.btcBalance = Number((state.btcBalance - amountBTC).toFixed(6));
  state.wBalance = Number((state.wBalance + w).toFixed(6));
  const tx = pushTx('DEPOSIT', `Deposited ${amountBTC} BTC → ${w} wSTRK. Note created.`, { noteId: state.notes.length - 1 });
  try { await navigator.clipboard.writeText(note); uiLog('Note copied to clipboard'); } catch(e){}
  savePublicState();
  renderAll();
  return note;
}
function autoSelectNotes(amount){
  amount = Number(amount);
  const available = state.notes.map((n, idx) => { const parts = n.split(':'); return { idx, note: n, leaf: parts[1], amt: Number(parts[2]) }; });
  available.sort((a,b) => b.amt - a.amt);
  const picked = []; let sum = 0;
  for (const a of available){
    if (sum >= amount) break;
    picked.push(a); sum += a.amt;
  }
  if (sum < amount) return null;
  return { picked, sum };
}
async function withdrawWithNote(noteStr, dest, gasless=false){
  if (!noteStr){ uiLog('Note required', 'error'); return null; }
  const parts = noteStr.split(':'); if (parts.length < 3){ uiLog('Bad note format', 'error'); return null; }
  const secret = parts[0], leaf = parts[1], amt = Number(parts[2]);
  const idx = state.leaves.indexOf(leaf);
  if (idx === -1){ uiLog('Note not found in pool (already spent?)', 'error'); return null; }
  const proof = await makeMerkleProof(state.leaves, idx);
  const root = await calcMerkleRoot(state.leaves);
  const nullifier = await hashAdapter.sha256Hex('null:' + noteStr);
  if (state.nulls.includes(nullifier)){ uiLog('Nullifier already used', 'error'); return null; }
  const ok = await verifyMerkleProof(leaf, proof, root, idx);
  if (!ok){ uiLog('Proof verification failed', 'error'); return null; }
  state.nulls.push(nullifier);
  state.leaves.splice(idx,1);
  const noteIdx = state.notes.indexOf(noteStr); if (noteIdx !== -1) state.notes.splice(noteIdx,1);
  state.wBalance = Number((state.wBalance - amt).toFixed(6));
  const tx = pushTx('WITHDRAW', `Withdraw ${amt} wSTRK → ${dest}. Gasless:${gasless}`, { nullifier, proofLen: proof.length });
  savePublicState();
  renderAll();
  return tx;
}
async function withdrawAmount(amount, dest, gasless=false){
  amount = Number(amount);
  if (isNaN(amount) || amount <= 0){ uiLog('Invalid amount', 'error'); return null; }
  if (amount > state.wBalance){ uiLog('Insufficient wrapped balance', 'error'); return null; }
  const selection = autoSelectNotes(amount);
  if (!selection){ uiLog('Insufficient notes to cover amount', 'error'); return null; }
  for (const p of selection.picked){
    const n = p.note;
    const nullifier = await hashAdapter.sha256Hex('null:' + n);
    state.nulls.push(nullifier);
    const leaf = p.leaf; const li = state.leaves.indexOf(leaf); if (li !== -1) state.leaves.splice(li,1);
    const ni = state.notes.indexOf(n); if (ni !== -1) state.notes.splice(ni,1);
  }
  const sum = selection.sum; const change = Number((sum - amount).toFixed(6));
  if (change > 0.000001){
    const cn = await createNoteForAmount(change); state.notes.push(cn); state.leaves.push(cn.split(':')[1]); uiLog(`Change note created: ${change} wSTRK`);
  }
  state.wBalance = Number((state.wBalance - amount).toFixed(6));
  pushTx('WITHDRAW', `Withdraw ${amount} wSTRK → ${dest} (used ${selection.picked.length} notes)`);
  savePublicState();
  renderAll();
  return true;
}

// -----------------------------
// Encrypted export/import (explicit user action)
// -----------------------------
async function exportEncrypted(password){
  if (!password){ uiLog('Password required', 'error'); return; }
  const enc = new TextEncoder(); const salt = crypto.getRandomValues(new Uint8Array(16));
  const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']);
  const key = await crypto.subtle.deriveKey({ name: 'PBKDF2', salt, iterations: 200000, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, true, ['encrypt']);
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const data = new TextEncoder().encode(JSON.stringify(state));
  const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, data);
  const payload = { s: btoa(String.fromCharCode(...salt)), i: btoa(String.fromCharCode(...iv)), c: btoa(String.fromCharCode(...new Uint8Array(ct))) };
  downloadText('bitshade_backup_enc.json', JSON.stringify(payload, null, 2));
  uiLog('Encrypted backup saved.');
}
async function importEncryptedFile(file, password){
  try {
    const txt = await file.text(); const payload = JSON.parse(txt);
    const salt = Uint8Array.from(atob(payload.s), c => c.charCodeAt(0));
    const iv = Uint8Array.from(atob(payload.i), c => c.charCodeAt(0));
    const ct = Uint8Array.from(atob(payload.c), c => c.charCodeAt(0));
    const keyMaterial = await crypto.subtle.importKey('raw', new TextEncoder().encode(password), { name: 'PBKDF2' }, false, ['deriveKey']);
    const key = await crypto.subtle.deriveKey({ name: 'PBKDF2', salt, iterations: 200000, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, true, ['decrypt']);
    const data = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
    const obj = JSON.parse(new TextDecoder().decode(data));
    state = obj;
    savePublicState();
    renderAll();
    uiLog('Encrypted backup imported successfully.');
  } catch (e) {
    uiLog('Import failed: ' + (e.message || e), 'error');
  }
}

// -----------------------------
// On-chain sync (UI placeholder)
// -----------------------------
$('btnSyncRootOnChain')?.addEventListener('click', async () => {
  const root = await calcMerkleRoot(state.leaves);
  if (!root) { uiLog('No root available to sync', 'error'); return; }
  const tx = pushTx('SYNC', `Stored Merkle root on-chain: ${root.substr(0,12)}...`, { root, txhash: fakeTxHash() });
  $('onchainStatus').textContent = `On-chain root stored — tx ${tx.meta.txhash}`;
});
$('btnCheckOnChain')?.addEventListener('click', () => {
  const last = state.txs.slice().reverse().find(t => t.type === 'SYNC');
  if(!last) { uiLog('No on-chain root found', 'error'); return; }
  $('onchainStatus').textContent = `On-chain root: ${last.meta.root.substr(0,12)}... tx:${last.meta.txhash}`;
  uiLog('Checked on-chain root');
});

// -----------------------------
// Onboarding & UI wiring
// -----------------------------
function renderOnboard(){
  const container = $('onboardChecks');
  container.innerHTML = '';
  const steps = [
    { id: 's-deposit', title: 'Create a note', desc: 'Create a private note by depositing.', ok: state.notes.length > 0 },
    { id: 's-inspect', title: 'Inspect Merkle root', desc: 'Open pool inspector and verify root.', ok: state.leaves.length > 0 },
    { id: 's-withdraw', title: 'Withdraw note', desc: 'Spend a note and observe nullifier creation.', ok: state.nulls.length > 0 },
    { id: 's-backup', title: 'Export backup', desc: 'Export an encrypted backup for recovery.', ok: false }
  ];
  steps.forEach(s => {
    const el = document.createElement('div'); el.className = 'onboard-check' + (s.ok ? ' completed' : '');
    el.innerHTML = `<div style="flex:1"><div style="font-weight:700">${s.title}</div><div class="small" style="margin-top:4px">${s.desc}</div></div>
      <div style="display:flex;gap:8px"><button class="ghost" data-action="${s.id}">${s.ok ? 'Done' : 'Start'}</button></div>`;
    container.appendChild(el);
  });
  container.querySelectorAll('[data-action]').forEach(b => b.onclick = () => {
    const a = b.getAttribute('data-action');
    if (a === 's-deposit') { $('depositAmount').value = '0.01'; $('btnDeposit').click(); }
    if (a === 's-inspect') { uiLog('Open pool inspector to review Merkle root'); document.querySelector('#merkleViz')?.scrollIntoView({behavior:'smooth'}); }
    if (a === 's-withdraw') { uiLog('Paste a note into Withdraw to spend it'); document.querySelector('#noteInput')?.focus(); }
    if (a === 's-backup') { $('btnExportEnc').click(); }
  });
}

// -----------------------------
// Wire controls
// -----------------------------
$('depositPreset')?.addEventListener('change', ()=>{ $('depositAmount').value = $('depositPreset').value; });
$('btnDeposit')?.addEventListener('click', async () => {
  const amt = $('depositAmount').value || '0.01';
  const note = await deposit(amt);
  if (note) uiLog(`Note created (${note.slice(0,12)}...) — keep it safe`);
  // Update counters
  $('statsDeposits').textContent = Number($('statsDeposits').textContent || 0) + 1;
});
$('btnBatchDeposit')?.addEventListener('click', async () => {
  for (let i=0;i<3;i++){ await deposit(0.01); await new Promise(r=>setTimeout(r,120)); }
  uiLog('Batch deposit completed');
  $('statsDeposits').textContent = Number($('statsDeposits').textContent || 0) + 3;
});

$('btnAutoSelect')?.addEventListener('click', ()=> {
  const amt = Number($('withdrawAmount').value || 0);
  if (!amt) { uiLog('Enter withdraw amount first', 'error'); return; }
  const sel = autoSelectNotes(amt); if (!sel) { uiLog('Auto-select failed (insufficient notes)', 'error'); return; }
  $('notesForSelect').innerHTML = sel.picked.map(p => `#${p.idx} ${p.amt} wSTRK`).join('<br>');
  uiLog('Notes auto-selected');
});

$('btnWithdraw')?.addEventListener('click', async () => {
  const note = $('noteInput').value.trim(); const amt = $('withdrawAmount').value; const dest = $('destAddr').value || '0xDEADBEEF'; const gasless = $('checkboxGasless').checked;
  if (note) { const tx = await withdrawWithNote(note, dest, gasless); if (tx) { uiLog('Withdraw processed'); $('statsWithdraws').textContent = Number($('statsWithdraws').textContent || 0) + 1; } return; }
  if (!amt) { uiLog('Enter withdraw amount or paste a note', 'error'); return; }
  const ok = await withdrawAmount(amt, dest, gasless);
  if (ok) { uiLog('Withdraw processed'); $('statsWithdraws').textContent = Number($('statsWithdraws').textContent || 0) + 1; }
});

$('btnVerifyProof')?.addEventListener('click', async () => {
  const pasted = $('noteInput').value.trim(); if (!pasted) { uiLog('Paste a note to verify', 'error'); return; }
  const parts = pasted.split(':'); const leaf = parts[1];
  const idx = state.leaves.indexOf(leaf);
  if (idx === -1) { uiLog('Leaf not found in pool', 'error'); return; }
  const proof = await makeMerkleProof(state.leaves, idx);
  const root = await calcMerkleRoot(state.leaves);
  const ok = await verifyMerkleProof(leaf, proof, root, idx);
  uiLog('Proof verify: ' + (ok ? 'OK' : 'FAILED'));
  $('statsProofs').textContent = Number($('statsProofs').textContent || 0) + 1;
});

$('btnShowTx')?.addEventListener('click', () => {
  const last = state.txs.slice().reverse()[0];
  if (!last) { uiLog('No transactions available', 'error'); return; }
  downloadText('proof_sample.json', JSON.stringify(last,null,2)); uiLog('Proof JSON exported');
});

// Export/import wiring
$('btnExportEnc')?.addEventListener('click', async () => {
  const pw = prompt('Enter password for encrypted export (strong):'); if (!pw) return;
  await exportEncrypted(pw);
});
$('btnImportEnc')?.addEventListener('click', () => {
  const f = document.createElement('input'); f.type = 'file'; f.accept = '.json'; f.onchange = e => {
    const file = e.target.files[0]; const pw = prompt('Enter password to decrypt:'); if (!pw) return; importEncryptedFile(file, pw);
  }; f.click();
});

// Reveal modal wiring
function showRevealModal(note){ $('revealText').textContent = note; showModal('revealModal'); }
$('revealClose')?.addEventListener('click', ()=> hideModal('revealModal'));
$('revealCopy')?.addEventListener('click', ()=> { const t = $('revealText').textContent || ''; copyToClipboard(t); uiLog('Note copied'); hideModal('revealModal'); });

function showModal(id){ const el = $(id); if(!el) return; el.style.display = 'flex'; el.setAttribute('aria-hidden','false'); }
function hideModal(id){ const el = $(id); if(!el) return; el.style.display = 'none'; el.setAttribute('aria-hidden','true'); }

// Confirm modal wiring
function showConfirm(msg, okCb){
  $('confirmText').textContent = msg; showModal('confirmModal');
  $('confirmOk').onclick = ()=>{ hideModal('confirmModal'); okCb && okCb(); };
  $('confirmCancel').onclick = ()=> hideModal('confirmModal');
}

// Acknowledge banner
$('btnAcknowledge')?.addEventListener('click', () => {
  // Hide banner (simple UX)
  const b = document.querySelector('.card'); if (b) b.style.display = 'none';
});

// Skip onboarding
$('btnSkipOnboard')?.addEventListener('click', ()=> { document.querySelector('#onboardChecks').innerHTML = '<div class="small" style="color:var(--muted)">Onboarding skipped</div>'; });

// Utility download last tx
function downloadProofForLast(){ const last = state.txs.slice().reverse()[0]; if (!last) return; downloadText('proof.json', JSON.stringify(last,null,2)); }

// -----------------------------
// Initial render and setup
// -----------------------------
renderAll();

// For convenience during local demo, expose state to console (dev only)
window.__bitshade_state = state;

</script>
</body>
</html>
